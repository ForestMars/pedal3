#!/usr/bin/env node
/**
 * Database Schema Generator Operator
 * 
 * Generates a Drizzle ORM schema and SQL migration scripts from Zod schemas.
 * 
 * Usage:
 *   node database_schema_generator.ts --input /path/to/zod_schemas.ts --output /path/to/db_schema.ts
 */

import * as fs from 'fs';
import * as path from 'path';
import { z } from 'zod';
import { createProgram, ScriptTarget, ModuleKind, ScriptKind } from 'typescript';
import { config } from '../config/storage.config';
import { createLogger } from '../utils/logger';
import { readFile, writeFile, getVersionedFilename, ensureDirectoryExists } from '../utils/file';

// Get task ID from environment variable or use default
const taskId = process.env.TASK_ID || 'database_schema_generator';
const logger = createLogger(taskId);

/**
 * Maps a Zod schema type to a Drizzle column type
 * @param zodType - Zod type string
 * @returns Drizzle column type info
 */
function mapZodTypeToDrizzle(zodType: string): { type: string, options?: Record<string, any> } {
  if (zodType.includes('z.string()')) {
    // Check for specific string formats
    if (zodType.includes('.uuid()')) {
      return { type: 'uuid' };
    } else if (zodType.includes('.datetime(')) {
      return { type: 'timestamp' };
    } else if (zodType.includes('.email()')) {
      return { type: 'varchar', options: { length: 255 } };
    } else if (zodType.includes('.url()')) {
      return { type: 'varchar', options: { length: 2048 } };
    } else if (zodType.includes('.min(') && zodType.includes('.max(')) {
      // Extract max length if present
      const maxMatch = zodType.match(/\.max\((\d+)/);
      const maxLength = maxMatch ? parseInt(maxMatch[1]) : 255;
      return { type: 'varchar', options: { length: maxLength } };
    } else {
      return { type: 'text' };
    }
  } else if (zodType.includes('z.number()')) {
    if (zodType.includes('.int()')) {
      return { type: 'integer' };
    } else {
      return { type: 'decimal', options: { precision: 10, scale: 2 } };
    }
  } else if (zodType.includes('z.boolean()')) {
    return { type: 'boolean' };
  } else if (zodType.includes('z.date()')) {
    return { type: 'timestamp' };
  } else if (zodType.includes('z.array(')) {
    return { type: 'jsonb' };
  } else if (zodType.includes('z.object(')) {
    return { type: 'jsonb' };
  } else if (zodType.includes('z.record(')) {
    return { type: 'jsonb' };
  } else if (zodType.includes('z.enum(')) {
    return { type: 'varchar', options: { length: 255 } };
  } else {
    // Default to text for unknown types
    return { type: 'text' };
  }
}

/**
 * Converts a Zod schema name to a table name
 * @param schemaName - Zod schema name
 * @returns Table name
 */
function schemaNameToTableName(schemaName: string): string {
  // Remove 'Schema' suffix if present
  let name = schemaName.replace(/Schema$/, '');
  
  // Convert CamelCase to snake_case
  return name
    .replace(/([A-Z])/g, '_$1')
    .toLowerCase()
    .replace(/^_/, '') // Remove leading underscore
    .replace(/([a-z])([0-9])/g, '$1_$2'); // Add underscore before numbers
}

/**
 * Analyzes a Zod schema and extracts field information
 * @param zodSchema - Zod schema string
 * @returns Array of field information
 */
function analyzeZodSchema(zodSchema: string): { name: string, type: string, required: boolean }[] {
  const fields: { name: string, type: string, required: boolean }[] = [];
  
  // Look for object definition
  const objectMatch = zodSchema.match(/z\.object\(\s*\{([^}]+)\}\s*\)/s);
  if (!objectMatch) return fields;
  
  const objectBody = objectMatch[1];
  
  // Extract field definitions
  const fieldRegex = /\s*(\w+)\s*:\s*(z\.[^,]+)/g;
  let match;
  
  while ((match = fieldRegex.exec(objectBody)) !== null) {
    const [_, fieldName, fieldType] = match;
    const isOptional = fieldType.includes('.optional()');
    
    fields.push({
      name: fieldName,
      type: fieldType.replace('.optional()', ''),
      required: !isOptional
    });
  }
  
  return fields;
}

/**
 * Generates Drizzle schema definition from zod schemas
 * @param zodSchemas - Map of schema name to field definitions
 * @returns Drizzle schema as string
 */
function generateDrizzleSchema(zodSchemas: Map<string, { name: string, type: string, required: boolean }[]>): string {
  let drizzleCode = `/**
 * Generated Drizzle schema from Zod schemas
 * Generated by PEDAL Database Schema Generator
 */

import { pgTable, text, integer, boolean, timestamp, uuid, varchar, decimal, jsonb, primaryKey, foreignKey, unique, index } from 'drizzle-orm/pg-core';
import { relations } from 'drizzle-orm';

// Drizzle schema definitions
`;

  // Generate table definitions
  for (const [schemaName, fields] of zodSchemas.entries()) {
    const tableName = schemaNameToTableName(schemaName);
    
    drizzleCode += `\n// Table for ${schemaName}\n`;
    drizzleCode += `export const ${tableName} = pgTable('${tableName}', {\n`;
    
    // Add id field if not present
    if (!fields.some(f => f.name === 'id')) {
      drizzleCode += `  id: uuid('id').primaryKey().defaultRandom(),\n`;
    }
    
    // Add fields
    for (const field of fields) {
      const drizzleType = mapZodTypeToDrizzle(field.type);
      
      // Generate column definition
      if (drizzleType.type === 'varchar') {
        const length = drizzleType.options?.length || 255;
        drizzleCode += `  ${field.name}: varchar('${field.name}', { length: ${length} })`;
      } else if (drizzleType.type === 'decimal') {
        const precision = drizzleType.options?.precision || 10;
        const scale = drizzleType.options?.scale || 2;
        drizzleCode += `  ${field.name}: decimal('${field.name}', { precision: ${precision}, scale: ${scale} })`;
      } else {
        drizzleCode += `  ${field.name}: ${drizzleType.type}('${field.name}')`;
      }
      
      // Add constraints
      if (field.name === 'id') {
        drizzleCode += `.primaryKey()`;
      }
      if (!field.required) {
        // Non-required fields are nullable
      } else {
        drizzleCode += `.notNull()`;
      }
      
      drizzleCode += `,\n`;
    }
    
    // Add created_at/updated_at if not present
    if (!fields.some(f => f.name === 'created_at')) {
      drizzleCode += `  created_at: timestamp('created_at').notNull().defaultNow(),\n`;
    }
    if (!fields.some(f => f.name === 'updated_at')) {
      drizzleCode += `  updated_at: timestamp('updated_at').notNull().defaultNow(),\n`;
    }
    
    drizzleCode += `});\n`;
    
    // Add relations template
    drizzleCode += `\n// Relations for ${tableName}\n`;
    drizzleCode += `export const ${tableName}Relations = relations(${tableName}, ({ one, many }) => ({\n`;
    drizzleCode += `  // Add relations here\n`;
    drizzleCode += `}));\n`;
  }

  return drizzleCode;
}

/**
 * Generates SQL migration script from zod schemas
 * @param zodSchemas - Map of schema name to field definitions
 * @returns SQL migration script as string
 */
function generateSqlMigration(zodSchemas: Map<string, { name: string, type: string, required: boolean }[]>): string {
  let sqlScript = `-- Migration script generated by PEDAL Database Schema Generator
-- Created at: ${new Date().toISOString()}

`;

  // Generate CREATE TABLE statements
  for (const [schemaName, fields] of zodSchemas.entries()) {
    const tableName = schemaNameToTableName(schemaName);
    
    sqlScript += `-- Table for ${schemaName}\n`;
    sqlScript += `CREATE TABLE IF NOT EXISTS ${tableName} (\n`;
    
    // Add id field if not present
    if (!fields.some(f => f.name === 'id')) {
      sqlScript += `  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n`;
    }
    
    // Add fields
    for (const field of fields) {
      const drizzleType = mapZodTypeToDrizzle(field.type);
      
      // Map to SQL type
      let sqlType: string;
      switch (drizzleType.type) {
        case 'varchar':
          sqlType = `VARCHAR(${drizzleType.options?.length || 255})`;
          break;
        case 'integer':
          sqlType = 'INTEGER';
          break;
        case 'decimal':
          sqlType = `DECIMAL(${drizzleType.options?.precision || 10}, ${drizzleType.options?.scale || 2})`;
          break;
        case 'boolean':
          sqlType = 'BOOLEAN';
          break;
        case 'timestamp':
          sqlType = 'TIMESTAMP WITH TIME ZONE';
          break;
        case 'uuid':
          sqlType = 'UUID';
          break;
        case 'jsonb':
          sqlType = 'JSONB';
          break;
        case 'text':
        default:
          sqlType = 'TEXT';
      }
      
      sqlScript += `  ${field.name} ${sqlType}`;
      
      // Add constraints
      if (field.name === 'id') {
        sqlScript += ' PRIMARY KEY';
      }
      if (field.required) {
        sqlScript += ' NOT NULL';
      }
      
      sqlScript += ',\n';
    }
    
    // Add created_at/updated_at if not present
    if (!fields.some(f => f.name === 'created_at')) {
      sqlScript += `  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),\n`;
    }
    if (!fields.some(f => f.name === 'updated_at')) {
      sqlScript += `  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),\n`;
    }
    
    // Remove trailing comma and close parenthesis
    sqlScript = sqlScript.replace(/,\n$/, '\n');
    sqlScript += `);\n\n`;
    
    // Add index for typical fields
    for (const field of fields) {
      if (['name', 'email', 'slug', 'external_id'].includes(field.name)) {
        sqlScript += `-- Index for ${field.name}\n`;
        sqlScript += `CREATE INDEX IF NOT EXISTS idx_${tableName}_${field.name} ON ${tableName} (${field.name});\n\n`;
      }
    }
  }

  return sqlScript;
}

/**
 * Runs the database schema generator process
 * @param inputPath - Path to the input TS file (Zod schemas)
 * @param outputPath - Path to the output TS file (Drizzle schema)
 * @returns Promise resolving when complete
 */
export async function run(inputPath: string, outputPath: string): Promise<void> {
  try {
    logger.info(`Starting database schema generation from ${inputPath} to ${outputPath}`);
    
    // Read Zod schemas file
    logger.info(`Reading Zod schemas from ${inputPath}`);
    const zodFileContent = fs.readFileSync(inputPath, 'utf-8');
    
    // Parse the file to extract schema definitions
    logger.info('Analyzing Zod schemas');
    
    // Extract export const declarations
    const schemaRegex = /export const (\w+Schema) = (z\.(?:object|lazy)\([^;]+);/g;
    let match;
    const zodSchemas = new Map<string, { name: string, type: string, required: boolean }[]>();
    
    while ((match = schemaRegex.exec(zodFileContent)) !== null) {
      const [_, schemaName, schemaDefinition] = match;
      
      // Skip schemas that aren't objects
      if (!schemaDefinition.includes('z.object') && !schemaDefinition.includes('z.lazy')) {
        continue;
      }
      
      // Analyze the schema structure
      const fields = analyzeZodSchema(schemaDefinition);
      if (fields.length > 0) {
        zodSchemas.set(schemaName, fields);
      }
    }
    
    logger.info(`Found ${zodSchemas.size} Zod schemas to convert`);
    
    // Generate Drizzle schema
    logger.info('Generating Drizzle schema');
    const drizzleSchema = generateDrizzleSchema(zodSchemas);
    
    // Write Drizzle schema to output file
    logger.info(`Writing Drizzle schema to ${outputPath}`);
    fs.writeFileSync(outputPath, drizzleSchema);
    
    // Also write versioned copy
    const baseOutputPath = outputPath.substring(0, outputPath.length - 3); // Remove .ts
    const versionedOutputPath = getVersionedFilename(baseOutputPath, '.ts');
    
    logger.info(`Writing versioned Drizzle schema to ${versionedOutputPath}`);
    fs.writeFileSync(versionedOutputPath, drizzleSchema);
    
    // Generate SQL migration script
    const migrationDir = path.join(path.dirname(outputPath), 'migrations');
    ensureDirectoryExists(migrationDir);
    
    const timestamp = new Date().toISOString().replace(/[-:]/g, '').split('.')[0];
    const migrationPath = path.join(migrationDir, `${timestamp}_initial_schema.sql`);
    
    logger.info(`Generating SQL migration script at ${migrationPath}`);
    const sqlMigration = generateSqlMigration(zodSchemas);
    fs.writeFileSync(migrationPath, sqlMigration);
    
    // Generate Supabase setup script (if configured)
    if (config.supabase.url && config.supabase.key) {
      const supabaseDir = path.join(path.dirname(outputPath), 'supabase');
      ensureDirectoryExists(supabaseDir);
      
      const supabaseSetupPath = path.join(supabaseDir, 'setup.ts');
      logger.info(`Generating Supabase setup script at ${supabaseSetupPath}`);
      
      const supabaseSetup = `/**
 * Supabase setup script generated by PEDAL
 */
import { createClient } from '@supabase/supabase-js';
import fs from 'fs';
import path from 'path';
import { config } from '../config/storage.config';

// Create Supabase client
const supabase = createClient(
  config.supabase.url,
  config.supabase.key
);

async function applySqlMigration(filePath: string) {
  const sql = fs.readFileSync(filePath, 'utf-8');
  
  console.log(\`Applying migration from \${filePath}...\`);
  
  const { error } = await supabase.rpc('exec_sql', { sql });
  
  if (error) {
    console.error('Error applying migration:', error);
    throw error;
  }
  
  console.log('Migration applied successfully');
}

async function main() {
  // Get all SQL files in the migrations directory
  const migrationsDir = path.join(__dirname, '../migrations');
  const migrationFiles = fs.readdirSync(migrationsDir)
    .filter(file => file.endsWith('.sql'))
    .sort();
  
  console.log(\`Found \${migrationFiles.length} migration files\`);
  
  // Apply each migration
  for (const file of migrationFiles) {
    const filePath = path.join(migrationsDir, file);
    await applySqlMigration(filePath);
  }
  
  console.log('All migrations applied successfully');
}

// Run migrations when executed directly
if (require.main === module) {
  main().catch(error => {
    console.error('Migration failed:', error);
    process.exit(1);
  });
}
`;
      
      fs.writeFileSync(supabaseSetupPath, supabaseSetup);
    }
    
    logger.info('Database schema generation completed successfully');
  } catch (error) {
    logger.error(`Database schema generation failed: ${error instanceof Error ? error.message : error}`);
    throw error;
  }
}

// When run directly from command line
if (require.main === module) {
  // Parse command line arguments
  const args = process.argv.slice(2);
  const inputIndex = args.indexOf('--input');
  const outputIndex = args.indexOf('--output');
  
  if (inputIndex === -1 || outputIndex === -1) {
    logger.error('Missing required arguments: --input and --output must be specified');
    console.error('Usage: node database_schema_generator.ts --input /path/to/zod_schemas.ts --output /path/to/db_schema.ts');
    process.exit(1);
  }
  
  const inputPath = args[inputIndex + 1];
  const outputPath = args[outputIndex + 1];
  
  if (!inputPath || !outputPath) {
    logger.error('Invalid arguments: paths must be specified for --input and --output');
    console.error('Usage: node database_schema_generator.ts --input /path/to/zod_schemas.ts --output /path/to/db_schema.ts');
    process.exit(1);
  }
  
  // Execute the operator
  run(inputPath, outputPath)
    .then(() => {
      process.exit(0);
    })
    .catch((error) => {
      logger.error(`Execution failed: ${error instanceof Error ? error.message : error}`);
      process.exit(1);
    });
}
